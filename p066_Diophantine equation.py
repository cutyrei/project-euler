# p066.py
""" 다음과 같은 2차 디오판토스 방정식이 있습니다.
x^2 – D*y^2 = 1
(역주: 디오판토스 방정식은 정수해만 허용하는 부정다항방정식입니다. 그 중에서도 여기 나온 형태는 펠의 방정식이라고 하는데, x/y로 √D의 근사값을 구하는 데 이용됩니다.)
예를 들어서 D=13일 때 x를 최소화하는 해는 649^2 – 13*180^2 = 1 이 됩니다.
D가 제곱수일 경우에는 위 식을 만족하는 자연수 해는 없다고 볼 수 있습니다.
D = {2, 3, 5, 6, 7} 에 대해서 x를 최소화하는 자연수 해를 찾아보면, 아래와 같은 결과를 얻게 됩니다.
3^2 – 2×2^2 = 1
2^2 – 3×1^2 = 1
9^2 – 5×4^2 = 1
5^2 – 6×2^2 = 1
8^2 – 7×3^2 = 1
위에서 보듯이 D ≤ 7 인 경우에 대해 x를 최소화하는 해를 구하면, x의 값이 가장 큰 것은 D=5일 때입니다.
D ≤ 1000 인 경우에 대해 x를 최소화하는 해를 구하면, 가장 큰 x의 값을 갖는 D는 얼마입니까? """

import time
start = time.time()

# [풀이 1] x^2 – D*y^2 = 1 를 만족하는 (x, y)에 대해서, √D에 대한 연분수꼴의 수렴과정을 x/y로 나타낼 때 (x, y)가 모두 정수이면서 식을 만족하는 최초의 값을 찾는다(D가 완전제곱수인 경우는 제외).
# 펠 방정식 : 방정식 x^2 - 2*y^2 = 1을 만족하는 x와 y의 비율 x/y는 y의 값이 커짐에 따라 (+/-)√2로 수렴한다.
# 예시 : √2 => [1;(2)] => '1/1', '3/2', '7/5', '17/12', '41/29', '99/70', '239/169', '577/408', '1393/985', '3363/2378', ...
# 위의 수렴과정에서 분자는 x, 분모는 y가 되며, 수렴과정의 짝수항이 위 식을 만족하는 (x, y) 정수해가 됨 : (3, 2), (17, 12), (99/70) ...

# 연분수 순환마디 찾기
def get_cf(n):    
    if n < 2 or int(n**0.5)**2 == n: return []
    a0 = int(n**0.5) 
    a, m, d = a0, 0, 1
    t = [a0] 
    while a != 2 * a0: 
        if a0 ** 2 == n: break
        m = d * a - m
        d = (n - m ** 2) // d        
        a = (a0 + m) // d
        t.append(a)
    return t

# 연분수 전개 : n=[a1,(a2,a3,...,an)] 연분수 전개에서 i번째 분수를 p(i)/q(i)라고 하면, p(i)=a(i)*p(i-1)+p(i-2) / q(i)=a(i)*q(i-1)+q(i-2)
def pell(d):
    cf = get_cf(d)
    l = len(cf)
    p, q = [0, 1], [1, 0] # p는 분자, q는 분모
    i = 0
    while True:
        a = i if i<l else (i-1)%(l-1)+1 # 순환마디 안에서 반복
        p.append( cf[a]*p[i+1] + p[i] )
        q.append( cf[a]*q[i+1] + q[i] )
        x, y = p[-1], q[-1]
        if x**2 - d*(y**2) == 1: break 
        i += 1
    return p[-1], q[-1]

# 1000 이하의 d 중 x 값이 가장 큰 경우 찾기 
result = (0, 0, 0)
for d in range(2, 1001):
    if int(d**0.5)**2 == d: continue
    x, y = pell(d)
    if x > result[0]:
        result = (x, y, d)
print(result)

print(time.time()-start)
